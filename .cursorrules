# SISTEMA SGMM - REGLAS DE DESARROLLO
# Sistema de GestiÃ³n de Gastos MÃ©dicos Mayores
# Arquitectura: Clean Architecture con Hexagonal Design

## ðŸŽ¯ OBJETIVO PRINCIPAL
Implementar un sistema SGMM funcional, escalable y mantenible siguiendo arquitectura limpia y principios SOLID.

## ðŸ“‹ REGLAS DE DESARROLLO OBLIGATORIAS

### 1. METODOLOGÃA DE BLOQUES DE TRABAJO
- **BLOQUES ATÃ“MICOS**: Unidades de trabajo completas de 30-90 minutos
- **VALIDACIÃ“N POR BLOQUE**: ValidaciÃ³n rÃ¡pida al finalizar cada bloque (5-10 min)
- **CERO DEUDA TÃ‰CNICA**: Resolver problemas crÃ­ticos inmediatamente
- **DOCUMENTACIÃ“N INLINE**: Comentarios en cÃ³digo + actualizaciÃ³n de README
- **COMMITS SIGNIFICATIVOS**: Un commit por bloque con mensaje descriptivo
- **CHECKPOINT**: Verificar que funciona antes de continuar al siguiente bloque

**Referencia**: Ver documentaciÃ³n de fases en `/docs/FASE_*.md` para detalles completos

### 2. CRITERIOS DE VALIDACIÃ“N POR TAREA OBLIGATORIOS
- **ANALIZAR IMPACTO COMPLETO**: Â¿QuÃ© se ve afectado por este cambio?
- **MAPEAR DEPENDENCIAS**: Â¿QuÃ© depende de esto y de quÃ© depende esto?
- **VERIFICAR IMPORTS**: Â¿EstÃ¡n correctos todos los imports necesarios?
- **COMPRENDER ECOSISTEMA**: Â¿CÃ³mo se integra esto con el resto del sistema?
- **VALIDAR CON GATES**: Ejecutar validaciones antes de aceptar cambios
- **ANÃLISIS FORENSE**: Investigar causa raÃ­z antes de implementar soluciones

### 3. DOCUMENTACIÃ“N COMO FUENTE DE VERDAD
- **CONSULTAR SIEMPRE**: `/docs` antes de implementar cualquier funcionalidad
- **DICCIONARIO DE DATOS**: `/docs/DATA_DICTIONARY.md` - **CONSULTA OBLIGATORIA** antes de queries Prisma
- **CONVENCIONES DE NOMENCLATURA**: `/docs/NAMING_CONVENTIONS.md` - GuÃ­a detallada
- **PLANES DE FASES**: `/docs/FASE_*.md` - **CONSULTA OBLIGATORIA** para implementaciÃ³n
- **DICCIONARIO = LEY**: Si hay conflicto entre cÃ³digo y diccionario, el diccionario tiene razÃ³n
- **ACTUALIZAR AL CERRAR**: Documentar cuando se completa un mÃ³dulo/funcionalidad
- **NO INVENTAR**: Usar la documentaciÃ³n existente como base
- **VALIDAR CONSISTENCIA**: Asegurar que documentaciÃ³n y cÃ³digo estÃ©n alineados

### 4. ARQUITECTURA Y PRINCIPIOS
- **CLEAN ARCHITECTURE**: Seguir capas bien definidas (Domain, Application, Infrastructure)
- **SOLID PRINCIPLES**: Aplicar los 5 principios en todo el cÃ³digo
- **HEXAGONAL DESIGN**: Desacoplar la lÃ³gica de negocio de la infraestructura
- **DEPENDENCY INJECTION**: Usar inyecciÃ³n de dependencias para desacoplamiento
- **INTERFACE SEGREGATION**: Crear interfaces especÃ­ficas y cohesivas
- **SINGLE RESPONSIBILITY**: Una clase = una responsabilidad
- **NO GOD CLASSES**: Evitar clases que hagan demasiado

### 2. DOCUMENTACIÃ“N COMO FUENTE DE VERDAD
- **CONSULTAR SIEMPRE**: `/docs` antes de implementar cualquier funcionalidad
- **DICCIONARIO DE DATOS**: `/docs/DATA_DICTIONARY.md` - **CONSULTA OBLIGATORIA** antes de queries
- **ESQUEMA DE BD**: `/docs/DATABASE_SCHEMA_COMPLETE.md` - **CONSULTA OBLIGATORIA** para estructura
- **HISTORIAS DE USUARIO**: Validar funcionalidades contra requirements
- **DICCIONARIO = LEY**: Si hay conflicto entre cÃ³digo y diccionario, el diccionario tiene razÃ³n
- **ACTUALIZAR DOCUMENTACIÃ“N**: Mantener docs sincronizadas con cÃ³digo

### 3. CONVENCIONES DE NOMENCLATURA

#### **Backend (Node.js + TypeScript)**
- **Archivos**: `kebab-case` (user-service.ts, employee-repository.ts)
- **Clases**: `PascalCase` (UserService, EmployeeRepository)
- **Interfaces**: `PascalCase` con prefijo `I` (IUserService, IEmployeeRepository)
- **Funciones**: `camelCase` (getUserById, createEmployee)
- **Constantes**: `UPPER_SNAKE_CASE` (MAX_FILE_SIZE, DEFAULT_TIMEOUT)
- **Variables**: `camelCase` (userEmail, employeeData)
- **Enums**: `PascalCase` (UserRole, EmployeeStatus)

#### **Frontend (React + TypeScript)**
- **Componentes**: `PascalCase` (UserProfile, EmployeeList)
- **Hooks**: `camelCase` con prefijo `use` (useAuth, useEmployeeData)
- **Archivos**: `kebab-case` (user-profile.tsx, employee-list.tsx)
- **Props**: `camelCase` (userId, employeeData)
- **Estados**: `camelCase` (isLoading, userData)

#### **Base de Datos**
- **Tablas**: `snake_case` en plural (employees, dependents)
- **Campos**: `snake_case` (employee_id, created_at)
- **Ãndices**: `idx_tabla_campo` (idx_employees_email)
- **Foreign Keys**: `fk_tabla_campo` (fk_dependents_employee_id)

### 4. ESTRUCTURA DE PROYECTO

#### **Backend Structure**
```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/           # Configuraciones
â”‚   â”œâ”€â”€ modules/          # MÃ³dulos de negocio
â”‚   â”‚   â”œâ”€â”€ employees/
â”‚   â”‚   â”‚   â”œâ”€â”€ domain/   # Entidades, interfaces, tipos
â”‚   â”‚   â”‚   â”œâ”€â”€ application/ # Casos de uso, servicios
â”‚   â”‚   â”‚   â””â”€â”€ infrastructure/ # Repositorios, adapters
â”‚   â”‚   â”œâ”€â”€ dependents/
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ reports/
â”‚   â”œâ”€â”€ shared/           # Utilidades compartidas
â”‚   â””â”€â”€ server.ts         # Punto de entrada
â”œâ”€â”€ prisma/               # Esquema y migraciones
â””â”€â”€ docs/                 # DocumentaciÃ³n tÃ©cnica
```

#### **Frontend Structure**
```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/       # Componentes reutilizables
â”‚   â”œâ”€â”€ pages/           # PÃ¡ginas de la aplicaciÃ³n
â”‚   â”œâ”€â”€ hooks/           # Custom hooks
â”‚   â”œâ”€â”€ services/        # Servicios de API
â”‚   â”œâ”€â”€ types/           # Tipos TypeScript
â”‚   â”œâ”€â”€ utils/           # Utilidades
â”‚   â””â”€â”€ styles/          # Estilos globales
â””â”€â”€ docs/                # DocumentaciÃ³n frontend
```

### 5. REGLAS DE CÃ“DIGO

#### **TypeScript**
- **STRICT MODE**: Siempre habilitado
- **NO ANY**: Evitar tipo `any`, usar tipos especÃ­ficos
- **INTERFACES**: Preferir interfaces sobre types para objetos
- **ENUMS**: Usar enums para valores constantes
- **NULL SAFETY**: Manejar null/undefined explÃ­citamente
- **ASYNC/AWAIT**: Preferir sobre Promises.then()

#### **Error Handling**
- **TRY-CATCH**: En todas las operaciones asÃ­ncronas
- **CUSTOM ERRORS**: Crear errores especÃ­ficos del dominio
- **LOGGING**: Registrar errores con contexto suficiente
- **USER-FRIENDLY**: Mostrar mensajes de error claros al usuario

#### **Testing**
- **UNIT TESTS**: Para lÃ³gica de negocio
- **INTEGRATION TESTS**: Para APIs y servicios
- **MOCKING**: Mockear dependencias externas
- **COVERAGE**: Mantener cobertura > 80%

### 6. REGLAS DE BASE DE DATOS

#### **Prisma ORM**
- **SCHEMA FIRST**: Definir esquema antes de cÃ³digo
- **MIGRATIONS**: Usar migraciones para cambios de BD
- **VALIDATIONS**: Validaciones en esquema Prisma
- **RELATIONS**: Definir relaciones explÃ­citas
- **INDEXES**: Crear Ã­ndices para campos de bÃºsqueda

#### **Queries**
- **PARAMETERIZED**: Usar parÃ¡metros, nunca concatenaciÃ³n
- **LIMITS**: Limitar resultados de consultas grandes
- **PAGINATION**: Para listas grandes
- **OPTIMIZATION**: Revisar performance de queries complejas

### 7. REGLAS DE SEGURIDAD

#### **AutenticaciÃ³n**
- **SAML**: Usar SAML con Google Workspace
- **JWT**: Para sesiones despuÃ©s de SAML
- **COOKIES**: HttpOnly, Secure, SameSite
- **TIMEOUT**: Sesiones con expiraciÃ³n automÃ¡tica

#### **AutorizaciÃ³n**
- **ROLE-BASED**: Sistema de roles (EMPLOYEE, HR_ADMIN, SUPER_ADMIN)
- **RESOURCE-BASED**: Empleados solo ven sus propios datos
- **MIDDLEWARE**: Validar permisos en cada endpoint

#### **Datos Sensibles**
- **ENCRYPTION**: Datos sensibles encriptados
- **AUDIT TRAIL**: Registrar todas las acciones
- **PRIVACY**: AceptaciÃ³n de aviso de privacidad obligatoria
- **SOFT DELETE**: Nunca eliminaciÃ³n fÃ­sica

### 8. REGLAS DE ARCHIVOS Y DOCUMENTOS

#### **Google Drive Integration**
- **STRUCTURE**: Organizar por empleado/dependiente
- **NAMING**: Usar ID compuesto (3619-a01)
- **VALIDATION**: Validar tamaÃ±o y tipo de archivo
- **SECURITY**: Control de acceso por roles

#### **File Upload**
- **MAX SIZE**: 5MB por archivo
- **ALLOWED TYPES**: PDF, JPG, JPEG, PNG
- **FIRST TIME**: Upload obligatorio para dependientes nuevos
- **METADATA**: Guardar informaciÃ³n de upload

### 9. REGLAS DE REPORTES

#### **GeneraciÃ³n**
- **ON-DEMAND**: Generar dinÃ¡micamente, no almacenar
- **VIEWS**: Usar vistas SQL para reportes complejos
- **FORMATS**: Excel, PDF, CSV
- **FILTERING**: Por compaÃ±Ã­a, fecha, estado

#### **Tipos de Reporte**
- **INSURER**: Para aseguradora con todos los dependientes
- **PAYROLL_DEDUCTIONS**: Para nÃ³minas con dependientes extra
- **AUDIT**: Trail de auditorÃ­a para RH

### 10. REGLAS DE PERFORMANCE

#### **Backend**
- **CACHING**: Cache para datos frecuentemente accedidos
- **PAGINATION**: Para listas grandes
- **LAZY LOADING**: Cargar datos bajo demanda
- **INDEXING**: Ãndices en campos de bÃºsqueda

#### **Frontend**
- **CODE SPLITTING**: Dividir cÃ³digo por rutas
- **LAZY LOADING**: Cargar componentes bajo demanda
- **OPTIMIZATION**: Optimizar imÃ¡genes y assets
- **BUNDLING**: Usar bundling eficiente

### 11. REGLAS DE DEPLOYMENT

#### **Docker**
- **MULTI-STAGE**: Builds optimizados
- **SECRETS**: Variables de entorno para secretos
- **HEALTH CHECKS**: Verificar salud de contenedores
- **LOGGING**: Configurar logging centralizado

#### **Environment**
- **SEPARATION**: Dev, Staging, Production
- **CONFIG**: Variables de entorno para configuraciÃ³n
- **SECRETS**: Nunca hardcodear secretos
- **BACKUPS**: Backup automÃ¡tico de BD

### 12. REGLAS DE COMMITS Y VERSIONADO

#### **Git Commits**
- **CONVENTIONAL**: Usar Conventional Commits
- **ATOMIC**: Un commit = una funcionalidad
- **DESCRIPTIVE**: Mensajes claros y descriptivos
- **SIGNED**: Firmar commits cuando sea posible

#### **Versionado**
- **SEMANTIC**: Semantic Versioning (MAJOR.MINOR.PATCH)
- **CHANGELOG**: Mantener changelog actualizado
- **TAGS**: Tag releases importantes

### 13. REGLAS DE MONITOREO Y LOGGING

#### **Logging**
- **STRUCTURED**: JSON logs para parsing
- **LEVELS**: DEBUG, INFO, WARN, ERROR
- **CONTEXT**: Incluir contexto suficiente
- **CORRELATION**: IDs de correlaciÃ³n para traces

#### **Monitoring**
- **METRICS**: MÃ©tricas de performance y uso
- **ALERTS**: Alertas para errores crÃ­ticos
- **DASHBOARDS**: Dashboards para monitoreo
- **HEALTH**: Health checks automÃ¡ticos

### 14. REGLAS DE DOCUMENTACIÃ“N

#### **Code Documentation**
- **JSDoc**: Documentar funciones pÃºblicas
- **README**: README actualizado por mÃ³dulo
- **API DOCS**: DocumentaciÃ³n de APIs
- **ARCHITECTURE**: Documentar decisiones arquitectÃ³nicas

#### **User Documentation**
- **USER STORIES**: Historias de usuario claras
- **REQUIREMENTS**: RF y RNF documentados
- **MANUALS**: Manuales de usuario
- **FAQ**: Preguntas frecuentes

### 15. REGLAS DE CALIDAD

#### **Code Quality**
- **LINTING**: ESLint, Prettier configurados
- **FORMATTING**: Formato consistente
- **COMPLEXITY**: Evitar complejidad ciclomÃ¡tica alta
- **DUPLICATION**: Evitar cÃ³digo duplicado

#### **Reviews**
- **PULL REQUESTS**: Review obligatorio
- **CHECKLIST**: Checklist de review
- **TESTING**: Verificar que tests pasen
- **DOCUMENTATION**: Verificar documentaciÃ³n actualizada

---

## ðŸš¨ VALIDACIONES OBLIGATORIAS ANTES DE COMMIT

### **Backend**
- [ ] Tests unitarios pasan
- [ ] Tests de integraciÃ³n pasan
- [ ] Linting sin errores
- [ ] Tipos TypeScript correctos
- [ ] DocumentaciÃ³n actualizada
- [ ] Schema Prisma validado
- [ ] Migraciones aplicadas

### **Frontend**
- [ ] Componentes renderizan correctamente
- [ ] Tests unitarios pasan
- [ ] Linting sin errores
- [ ] Tipos TypeScript correctos
- [ ] Responsive design verificado
- [ ] Accesibilidad bÃ¡sica verificada

### **General**
- [ ] Funcionalidad probada manualmente
- [ ] Performance aceptable
- [ ] Seguridad verificada
- [ ] DocumentaciÃ³n actualizada
- [ ] Commits atÃ³micos y descriptivos

---

## ðŸ“‹ CHECKLIST DE ANÃLISIS ANTES DE CAMBIOS

### **Impacto**
- [ ] Â¿QuÃ© mÃ³dulos se ven afectados?
- [ ] Â¿QuÃ© dependencias externas hay?
- [ ] Â¿QuÃ© APIs cambian?
- [ ] Â¿QuÃ© base de datos se modifica?

### **Arquitectura**
- [ ] Â¿Sigue principios SOLID?
- [ ] Â¿Mantiene clean architecture?
- [ ] Â¿No viola separaciÃ³n de capas?
- [ ] Â¿Es testable?

### **Seguridad**
- [ ] Â¿Se validan inputs?
- [ ] Â¿Se manejan errores correctamente?
- [ ] Â¿Se registra en audit trail?
- [ ] Â¿Se respetan permisos?

### **Performance**
- [ ] Â¿Se optimizan queries?
- [ ] Â¿Se usa caching cuando corresponde?
- [ ] Â¿Se evitan N+1 queries?
- [ ] Â¿Se limitan resultados?

---

## ðŸŽ¯ OBJETIVOS DE CALIDAD

- **Cobertura de tests**: > 80%
- **Performance**: < 2s respuesta API
- **Disponibilidad**: 99.9%
- **Seguridad**: 0 vulnerabilidades crÃ­ticas
- **Mantenibilidad**: Complejidad ciclomÃ¡tica < 10
- **DocumentaciÃ³n**: 100% de APIs documentadas

---

*Ãšltima actualizaciÃ³n: 2025-01-15*
*VersiÃ³n: 1.0*
*Responsable: Equipo de Desarrollo SGMM*