# SISTEMA SGMM - REGLAS DE DESARROLLO
# Sistema de GestiÃ³n de Gastos MÃ©dicos Mayores
# Arquitectura: Clean Architecture con Hexagonal Design

## ðŸŽ¯ OBJETIVO PRINCIPAL
Implementar un sistema SGMM funcional, escalable y mantenible siguiendo arquitectura limpia y principios SOLID.

## ðŸ“‹ REGLAS DE DESARROLLO OBLIGATORIAS

### 1. METODOLOGÃA DE BLOQUES DE TRABAJO
- **BLOQUES ATÃ“MICOS**: Unidades de trabajo completas de 30-90 minutos
- **REVISIÃ“N OBLIGATORIA**: Consultar fuentes de verdad ANTES de iniciar cada bloque
- **VALIDACIÃ“N POR BLOQUE**: ValidaciÃ³n rÃ¡pida al finalizar cada bloque (5-10 min)
- **CERO DEUDA TÃ‰CNICA**: Resolver problemas crÃ­ticos inmediatamente
- **DOCUMENTACIÃ“N INLINE**: Comentarios en cÃ³digo + actualizaciÃ³n de README
- **COMMITS SIGNIFICATIVOS**: Un commit por bloque con mensaje descriptivo
- **CHECKPOINT**: Verificar que funciona antes de continuar al siguiente bloque

**Referencia**: Ver documentaciÃ³n de fases en `/docs/FASE_*.md` para detalles completos

### 2. CRITERIOS DE VALIDACIÃ“N POR TAREA OBLIGATORIOS
- **ANALIZAR IMPACTO COMPLETO**: Â¿QuÃ© se ve afectado por este cambio?
- **MAPEAR DEPENDENCIAS**: Â¿QuÃ© depende de esto y de quÃ© depende esto?
- **VERIFICAR IMPORTS**: Â¿EstÃ¡n correctos todos los imports necesarios?
- **COMPRENDER ECOSISTEMA**: Â¿CÃ³mo se integra esto con el resto del sistema?
- **VALIDAR CON GATES**: Ejecutar validaciones antes de aceptar cambios
- **ANÃLISIS FORENSE**: Investigar causa raÃ­z antes de implementar soluciones

### 3. REVISIÃ“N OBLIGATORIA DE FUENTES DE VERDAD (ANTES DE CADA BLOQUE)

#### **CHECKLIST OBLIGATORIO AL INICIO DE CADA BLOQUE**:
- [ ] **DATA_DICTIONARY.md**: Revisar campos, tipos, restricciones y reglas de negocio
- [ ] **DATABASE_SCHEMA_COMPLETE.md**: Validar estructura de tablas y relaciones
- [ ] **NAMING_CONVENTIONS.md**: Verificar convenciones de nomenclatura aplicables
- [ ] **USER_STORIES_GAP_ANALYSIS.md**: Confirmar funcionalidades requeridas
- [ ] **RF_RNF_VALIDATION.md**: Validar requerimientos funcionales y no funcionales
- [ ] **FASE_*.md**: Revisar plan especÃ­fico del bloque a implementar
- [ ] **MASTER_PLAN**: Si existe, revisar documentaciÃ³n del plan maestro

#### **VALIDACIÃ“N DE CONSISTENCIA**:
- [ ] **Campos de BD**: Â¿Existen todos los campos necesarios en el esquema?
- [ ] **Nomenclatura**: Â¿Sigo las convenciones establecidas?
- [ ] **Arquitectura**: Â¿Mantengo clean architecture y principios SOLID?
- [ ] **Dependencias**: Â¿Identifico todas las dependencias del mÃ³dulo?
- [ ] **Impacto**: Â¿Entiendo el impacto en otros mÃ³dulos?

#### **DOCUMENTACIÃ“N COMO FUENTE DE VERDAD**:
- **CONSULTAR SIEMPRE**: `/docs` antes de implementar cualquier funcionalidad
- **DICCIONARIO DE DATOS**: `/docs/DATA_DICTIONARY.md` - **CONSULTA OBLIGATORIA** antes de queries Prisma
- **CONVENCIONES DE NOMENCLATURA**: `/docs/NAMING_CONVENTIONS.md` - GuÃ­a detallada
- **PLANES DE FASES**: `/docs/FASE_*.md` - **CONSULTA OBLIGATORIA** para implementaciÃ³n
- **DICCIONARIO = LEY**: Si hay conflicto entre cÃ³digo y diccionario, el diccionario tiene razÃ³n
- **ACTUALIZAR AL CERRAR**: Documentar cuando se completa un mÃ³dulo/funcionalidad
- **NO INVENTAR**: Usar la documentaciÃ³n existente como base
- **VALIDAR CONSISTENCIA**: Asegurar que documentaciÃ³n y cÃ³digo estÃ©n alineados

### 4. VALIDACIÃ“N DE CALIDAD ARQUITECTURAL (OBLIGATORIA)

#### **PRINCIPIOS ARQUITECTURALES OBLIGATORIOS**:
- **CLEAN ARCHITECTURE**: Seguir capas bien definidas (Domain, Application, Infrastructure)
- **SOLID PRINCIPLES**: Aplicar los 5 principios en todo el cÃ³digo
- **HEXAGONAL DESIGN**: Desacoplar la lÃ³gica de negocio de la infraestructura
- **DEPENDENCY INJECTION**: Usar inyecciÃ³n de dependencias para desacoplamiento
- **INTERFACE SEGREGATION**: Crear interfaces especÃ­ficas y cohesivas
- **SINGLE RESPONSIBILITY**: Una clase = una responsabilidad
- **NO GOD CLASSES**: Evitar clases que hagan demasiado

#### **VALIDACIÃ“N DE PATRONES DE DISEÃ‘O**:
- [ ] **Repository Pattern**: Â¿Uso repositorios para acceso a datos?
- [ ] **Service Layer**: Â¿Separo lÃ³gica de negocio en servicios?
- [ ] **DTO Pattern**: Â¿Uso DTOs para transferencia de datos?
- [ ] **Factory Pattern**: Â¿Uso factories para creaciÃ³n de objetos complejos?
- [ ] **Observer Pattern**: Â¿Implemento notificaciones correctamente?
- [ ] **Strategy Pattern**: Â¿Uso estrategias para algoritmos variables?

#### **VALIDACIÃ“N DE NAMING CONVENTIONS**:
- [ ] **Backend**: Â¿Sigo kebab-case para archivos, PascalCase para clases?
- [ ] **Frontend**: Â¿Sigo PascalCase para componentes, camelCase para funciones?
- [ ] **Base de Datos**: Â¿Uso snake_case para tablas y campos?
- [ ] **Interfaces**: Â¿Uso prefijo 'I' para interfaces?
- [ ] **Constantes**: Â¿Uso UPPER_SNAKE_CASE para constantes?
- [ ] **Enums**: Â¿Uso PascalCase para enums?

#### **VALIDACIÃ“N DE ESTRUCTURA DE PROYECTO**:
- [ ] **SeparaciÃ³n de Capas**: Â¿Mantengo Domain, Application, Infrastructure separados?
- [ ] **MÃ³dulos**: Â¿Organizo por mÃ³dulos de negocio?
- [ ] **Dependencias**: Â¿Las dependencias apuntan hacia adentro (hacia Domain)?
- [ ] **Interfaces**: Â¿Defino interfaces en la capa de dominio?
- [ ] **Implementaciones**: Â¿Implemento en la capa de infraestructura?

### 2. DOCUMENTACIÃ“N COMO FUENTE DE VERDAD
- **CONSULTAR SIEMPRE**: `/docs` antes de implementar cualquier funcionalidad
- **DICCIONARIO DE DATOS**: `/docs/DATA_DICTIONARY.md` - **CONSULTA OBLIGATORIA** antes de queries
- **ESQUEMA DE BD**: `/docs/DATABASE_SCHEMA_COMPLETE.md` - **CONSULTA OBLIGATORIA** para estructura
- **HISTORIAS DE USUARIO**: Validar funcionalidades contra requirements
- **DICCIONARIO = LEY**: Si hay conflicto entre cÃ³digo y diccionario, el diccionario tiene razÃ³n
- **ACTUALIZAR DOCUMENTACIÃ“N**: Mantener docs sincronizadas con cÃ³digo

### 3. CONVENCIONES DE NOMENCLATURA

#### **Backend (Node.js + TypeScript)**
- **Archivos**: `kebab-case` (user-service.ts, employee-repository.ts)
- **Clases**: `PascalCase` (UserService, EmployeeRepository)
- **Interfaces**: `PascalCase` con prefijo `I` (IUserService, IEmployeeRepository)
- **Funciones**: `camelCase` (getUserById, createEmployee)
- **Constantes**: `UPPER_SNAKE_CASE` (MAX_FILE_SIZE, DEFAULT_TIMEOUT)
- **Variables**: `camelCase` (userEmail, employeeData)
- **Enums**: `PascalCase` (UserRole, EmployeeStatus)

#### **Frontend (React + TypeScript)**
- **Componentes**: `PascalCase` (UserProfile, EmployeeList)
- **Hooks**: `camelCase` con prefijo `use` (useAuth, useEmployeeData)
- **Archivos**: `kebab-case` (user-profile.tsx, employee-list.tsx)
- **Props**: `camelCase` (userId, employeeData)
- **Estados**: `camelCase` (isLoading, userData)

#### **Base de Datos**
- **Tablas**: `snake_case` en plural (employees, dependents)
- **Campos**: `snake_case` (employee_id, created_at)
- **Ãndices**: `idx_tabla_campo` (idx_employees_email)
- **Foreign Keys**: `fk_tabla_campo` (fk_dependents_employee_id)

### 4. ESTRUCTURA DE PROYECTO

#### **Backend Structure**
```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/           # Configuraciones
â”‚   â”œâ”€â”€ modules/          # MÃ³dulos de negocio
â”‚   â”‚   â”œâ”€â”€ employees/
â”‚   â”‚   â”‚   â”œâ”€â”€ domain/   # Entidades, interfaces, tipos
â”‚   â”‚   â”‚   â”œâ”€â”€ application/ # Casos de uso, servicios
â”‚   â”‚   â”‚   â””â”€â”€ infrastructure/ # Repositorios, adapters
â”‚   â”‚   â”œâ”€â”€ dependents/
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ reports/
â”‚   â”œâ”€â”€ shared/           # Utilidades compartidas
â”‚   â””â”€â”€ server.ts         # Punto de entrada
â”œâ”€â”€ prisma/               # Esquema y migraciones
â””â”€â”€ docs/                 # DocumentaciÃ³n tÃ©cnica
```

#### **Frontend Structure**
```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/       # Componentes reutilizables
â”‚   â”œâ”€â”€ pages/           # PÃ¡ginas de la aplicaciÃ³n
â”‚   â”œâ”€â”€ hooks/           # Custom hooks
â”‚   â”œâ”€â”€ services/        # Servicios de API
â”‚   â”œâ”€â”€ types/           # Tipos TypeScript
â”‚   â”œâ”€â”€ utils/           # Utilidades
â”‚   â””â”€â”€ styles/          # Estilos globales
â””â”€â”€ docs/                # DocumentaciÃ³n frontend
```

### 5. REGLAS DE CÃ“DIGO

#### **TypeScript**
- **STRICT MODE**: Siempre habilitado
- **NO ANY**: Evitar tipo `any`, usar tipos especÃ­ficos
- **INTERFACES**: Preferir interfaces sobre types para objetos
- **ENUMS**: Usar enums para valores constantes
- **NULL SAFETY**: Manejar null/undefined explÃ­citamente
- **ASYNC/AWAIT**: Preferir sobre Promises.then()

#### **Error Handling**
- **TRY-CATCH**: En todas las operaciones asÃ­ncronas
- **CUSTOM ERRORS**: Crear errores especÃ­ficos del dominio
- **LOGGING**: Registrar errores con contexto suficiente
- **USER-FRIENDLY**: Mostrar mensajes de error claros al usuario

#### **Testing**
- **UNIT TESTS**: Para lÃ³gica de negocio
- **INTEGRATION TESTS**: Para APIs y servicios
- **MOCKING**: Mockear dependencias externas
- **COVERAGE**: Mantener cobertura > 80%

### 6. REGLAS DE BASE DE DATOS

#### **Prisma ORM**
- **SCHEMA FIRST**: Definir esquema antes de cÃ³digo
- **MIGRATIONS**: Usar migraciones para cambios de BD
- **VALIDATIONS**: Validaciones en esquema Prisma
- **RELATIONS**: Definir relaciones explÃ­citas
- **INDEXES**: Crear Ã­ndices para campos de bÃºsqueda

#### **Queries**
- **PARAMETERIZED**: Usar parÃ¡metros, nunca concatenaciÃ³n
- **LIMITS**: Limitar resultados de consultas grandes
- **PAGINATION**: Para listas grandes
- **OPTIMIZATION**: Revisar performance de queries complejas

### 7. REGLAS DE SEGURIDAD

#### **AutenticaciÃ³n**
- **SAML**: Usar SAML con Google Workspace
- **JWT**: Para sesiones despuÃ©s de SAML
- **COOKIES**: HttpOnly, Secure, SameSite
- **TIMEOUT**: Sesiones con expiraciÃ³n automÃ¡tica

#### **AutorizaciÃ³n**
- **ROLE-BASED**: Sistema de roles (EMPLOYEE, HR_ADMIN, SUPER_ADMIN)
- **RESOURCE-BASED**: Empleados solo ven sus propios datos
- **MIDDLEWARE**: Validar permisos en cada endpoint

#### **Datos Sensibles**
- **ENCRYPTION**: Datos sensibles encriptados
- **AUDIT TRAIL**: Registrar todas las acciones
- **PRIVACY**: AceptaciÃ³n de aviso de privacidad obligatoria
- **SOFT DELETE**: Nunca eliminaciÃ³n fÃ­sica

### 8. REGLAS DE ARCHIVOS Y DOCUMENTOS

#### **Google Drive Integration**
- **STRUCTURE**: Organizar por empleado/dependiente
- **NAMING**: Usar ID compuesto (3619-a01)
- **VALIDATION**: Validar tamaÃ±o y tipo de archivo
- **SECURITY**: Control de acceso por roles

#### **File Upload**
- **MAX SIZE**: 5MB por archivo
- **ALLOWED TYPES**: PDF, JPG, JPEG, PNG
- **FIRST TIME**: Upload obligatorio para dependientes nuevos
- **METADATA**: Guardar informaciÃ³n de upload

### 9. REGLAS DE REPORTES

#### **GeneraciÃ³n**
- **ON-DEMAND**: Generar dinÃ¡micamente, no almacenar
- **VIEWS**: Usar vistas SQL para reportes complejos
- **FORMATS**: Excel, PDF, CSV
- **FILTERING**: Por compaÃ±Ã­a, fecha, estado

#### **Tipos de Reporte**
- **INSURER**: Para aseguradora con todos los dependientes
- **PAYROLL_DEDUCTIONS**: Para nÃ³minas con dependientes extra
- **AUDIT**: Trail de auditorÃ­a para RH

### 10. REGLAS DE PERFORMANCE

#### **Backend**
- **CACHING**: Cache para datos frecuentemente accedidos
- **PAGINATION**: Para listas grandes
- **LAZY LOADING**: Cargar datos bajo demanda
- **INDEXING**: Ãndices en campos de bÃºsqueda

#### **Frontend**
- **CODE SPLITTING**: Dividir cÃ³digo por rutas
- **LAZY LOADING**: Cargar componentes bajo demanda
- **OPTIMIZATION**: Optimizar imÃ¡genes y assets
- **BUNDLING**: Usar bundling eficiente

### 11. REGLAS DE DEPLOYMENT

#### **Docker**
- **MULTI-STAGE**: Builds optimizados
- **SECRETS**: Variables de entorno para secretos
- **HEALTH CHECKS**: Verificar salud de contenedores
- **LOGGING**: Configurar logging centralizado

#### **Environment**
- **SEPARATION**: Dev, Staging, Production
- **CONFIG**: Variables de entorno para configuraciÃ³n
- **SECRETS**: Nunca hardcodear secretos
- **BACKUPS**: Backup automÃ¡tico de BD

### 12. REGLAS DE COMMITS Y VERSIONADO

#### **Git Commits**
- **CONVENTIONAL**: Usar Conventional Commits
- **ATOMIC**: Un commit = una funcionalidad
- **DESCRIPTIVE**: Mensajes claros y descriptivos
- **SIGNED**: Firmar commits cuando sea posible

#### **Versionado**
- **SEMANTIC**: Semantic Versioning (MAJOR.MINOR.PATCH)
- **CHANGELOG**: Mantener changelog actualizado
- **TAGS**: Tag releases importantes

### 13. REGLAS DE MONITOREO Y LOGGING

#### **Logging**
- **STRUCTURED**: JSON logs para parsing
- **LEVELS**: DEBUG, INFO, WARN, ERROR
- **CONTEXT**: Incluir contexto suficiente
- **CORRELATION**: IDs de correlaciÃ³n para traces

#### **Monitoring**
- **METRICS**: MÃ©tricas de performance y uso
- **ALERTS**: Alertas para errores crÃ­ticos
- **DASHBOARDS**: Dashboards para monitoreo
- **HEALTH**: Health checks automÃ¡ticos

### 14. REGLAS DE DOCUMENTACIÃ“N

#### **Code Documentation**
- **JSDoc**: Documentar funciones pÃºblicas
- **README**: README actualizado por mÃ³dulo
- **API DOCS**: DocumentaciÃ³n de APIs
- **ARCHITECTURE**: Documentar decisiones arquitectÃ³nicas

#### **User Documentation**
- **USER STORIES**: Historias de usuario claras
- **REQUIREMENTS**: RF y RNF documentados
- **MANUALS**: Manuales de usuario
- **FAQ**: Preguntas frecuentes

### 15. REGLAS DE CALIDAD

#### **Code Quality**
- **LINTING**: ESLint, Prettier configurados
- **FORMATTING**: Formato consistente
- **COMPLEXITY**: Evitar complejidad ciclomÃ¡tica alta
- **DUPLICATION**: Evitar cÃ³digo duplicado

#### **Reviews**
- **PULL REQUESTS**: Review obligatorio
- **CHECKLIST**: Checklist de review
- **TESTING**: Verificar que tests pasen
- **DOCUMENTATION**: Verificar documentaciÃ³n actualizada

---

## ðŸš¨ VALIDACIONES OBLIGATORIAS ANTES DE COMMIT

### **Backend**
- [ ] Tests unitarios pasan
- [ ] Tests de integraciÃ³n pasan
- [ ] Linting sin errores
- [ ] Tipos TypeScript correctos
- [ ] DocumentaciÃ³n actualizada
- [ ] Schema Prisma validado
- [ ] Migraciones aplicadas

### **Frontend**
- [ ] Componentes renderizan correctamente
- [ ] Tests unitarios pasan
- [ ] Linting sin errores
- [ ] Tipos TypeScript correctos
- [ ] Responsive design verificado
- [ ] Accesibilidad bÃ¡sica verificada

### **General**
- [ ] Funcionalidad probada manualmente
- [ ] Performance aceptable
- [ ] Seguridad verificada
- [ ] DocumentaciÃ³n actualizada
- [ ] Commits atÃ³micos y descriptivos

---

## ðŸ“‹ PROCESO DE VALIDACIÃ“N POR BLOQUE (OBLIGATORIO)

### **FASE 1: REVISIÃ“N DE FUENTES DE VERDAD (ANTES DE INICIAR)**
- [ ] **DATA_DICTIONARY.md**: Campos, tipos, restricciones, reglas de negocio
- [ ] **DATABASE_SCHEMA_COMPLETE.md**: Estructura de tablas y relaciones
- [ ] **NAMING_CONVENTIONS.md**: Convenciones aplicables al bloque
- [ ] **USER_STORIES_GAP_ANALYSIS.md**: Funcionalidades requeridas
- [ ] **RF_RNF_VALIDATION.md**: Requerimientos funcionales y no funcionales
- [ ] **FASE_*.md**: Plan especÃ­fico del bloque
- [ ] **MASTER_PLAN**: DocumentaciÃ³n del plan maestro (si aplica)

### **FASE 2: ANÃLISIS DE IMPACTO (DURANTE EL BLOQUE)**
- [ ] **MÃ³dulos afectados**: Â¿QuÃ© mÃ³dulos se ven afectados?
- [ ] **Dependencias**: Â¿QuÃ© depende de esto y de quÃ© depende esto?
- [ ] **APIs**: Â¿QuÃ© endpoints cambian?
- [ ] **Base de datos**: Â¿QuÃ© tablas/campos se modifican?
- [ ] **Frontend**: Â¿QuÃ© componentes se ven afectados?

### **FASE 3: VALIDACIÃ“N ARQUITECTURAL (DURANTE EL BLOQUE)**
- [ ] **Principios SOLID**: Â¿Aplico los 5 principios?
- [ ] **Clean Architecture**: Â¿Mantengo separaciÃ³n de capas?
- [ ] **Patrones de diseÃ±o**: Â¿Uso patrones apropiados?
- [ ] **Naming conventions**: Â¿Sigo convenciones establecidas?
- [ ] **Estructura de proyecto**: Â¿Mantengo organizaciÃ³n por mÃ³dulos?

### **FASE 4: VALIDACIÃ“N DE CALIDAD (AL FINALIZAR)**
- [ ] **Funcionalidad**: Â¿El bloque cumple su objetivo?
- [ ] **Tests**: Â¿Tests unitarios e integraciÃ³n pasan?
- [ ] **Performance**: Â¿Rendimiento aceptable?
- [ ] **Seguridad**: Â¿Validaciones y permisos correctos?
- [ ] **DocumentaciÃ³n**: Â¿DocumentaciÃ³n actualizada?

### **FASE 5: CHECKPOINT (ANTES DE CONTINUAR)**
- [ ] **Funcionalidad probada**: Â¿ProbÃ© manualmente?
- [ ] **Sin errores**: Â¿No hay errores de compilaciÃ³n?
- [ ] **Tests pasando**: Â¿Todos los tests pasan?
- [ ] **Commit realizado**: Â¿Commit atÃ³mico y descriptivo?
- [ ] **DocumentaciÃ³n actualizada**: Â¿README y docs actualizados?

## ðŸ“‹ CHECKLIST DE ANÃLISIS ANTES DE CAMBIOS

### **Impacto**
- [ ] Â¿QuÃ© mÃ³dulos se ven afectados?
- [ ] Â¿QuÃ© dependencias externas hay?
- [ ] Â¿QuÃ© APIs cambian?
- [ ] Â¿QuÃ© base de datos se modifica?

### **Arquitectura**
- [ ] Â¿Sigue principios SOLID?
- [ ] Â¿Mantiene clean architecture?
- [ ] Â¿No viola separaciÃ³n de capas?
- [ ] Â¿Es testable?

### **Seguridad**
- [ ] Â¿Se validan inputs?
- [ ] Â¿Se manejan errores correctamente?
- [ ] Â¿Se registra en audit trail?
- [ ] Â¿Se respetan permisos?

### **Performance**
- [ ] Â¿Se optimizan queries?
- [ ] Â¿Se usa caching cuando corresponde?
- [ ] Â¿Se evitan N+1 queries?
- [ ] Â¿Se limitan resultados?

---

## ðŸ”§ COMANDOS DE VALIDACIÃ“N OBLIGATORIOS

### **ValidaciÃ³n de Fuentes de Verdad**
```bash
# Verificar que documentaciÃ³n existe y estÃ¡ actualizada
ls -la docs/DATA_DICTIONARY.md
ls -la docs/DATABASE_SCHEMA_COMPLETE.md
ls -la docs/NAMING_CONVENTIONS.md
ls -la docs/USER_STORIES_GAP_ANALYSIS.md
ls -la docs/RF_RNF_VALIDATION.md

# Verificar plan de fase especÃ­fico
ls -la docs/FASE_*.md
ls -la docs/masterPlan/
```

### **ValidaciÃ³n de CÃ³digo Backend**
```bash
# Compilar TypeScript
cd backend && npx tsc --noEmit

# Ejecutar tests
npm test

# Linting
npm run lint

# Verificar Prisma
npx prisma generate
npx prisma validate
```

### **ValidaciÃ³n de CÃ³digo Frontend**
```bash
# Compilar TypeScript
cd frontend && npx tsc --noEmit

# Ejecutar tests
npm test

# Linting
npm run lint

# Build de producciÃ³n
npm run build
```

### **ValidaciÃ³n de Base de Datos**
```bash
# Verificar migraciones
npx prisma migrate status

# Validar esquema
npx prisma validate

# Generar cliente
npx prisma generate
```

### **ValidaciÃ³n de Arquitectura**
```bash
# Verificar estructura de carpetas
find src -type d -name "domain" -o -name "application" -o -name "infrastructure"

# Verificar imports (dependencias hacia adentro)
grep -r "import.*domain" src/infrastructure/
grep -r "import.*infrastructure" src/domain/

# Verificar convenciones de nomenclatura
find src -name "*.ts" | xargs grep -l "class.*[A-Z]"
find src -name "*.ts" | xargs grep -l "interface.*[A-Z]"
```

## ðŸŽ¯ OBJETIVOS DE CALIDAD

- **Cobertura de tests**: > 80%
- **Performance**: < 2s respuesta API
- **Disponibilidad**: 99.9%
- **Seguridad**: 0 vulnerabilidades crÃ­ticas
- **Mantenibilidad**: Complejidad ciclomÃ¡tica < 10
- **DocumentaciÃ³n**: 100% de APIs documentadas

---

*Ãšltima actualizaciÃ³n: 2025-01-15*
*VersiÃ³n: 2.0*
*Responsable: Equipo de Desarrollo SGMM*

## ðŸ“‹ CAMBIOS EN VERSIÃ“N 2.0

### **Nuevas Funcionalidades**:
- âœ… **RevisiÃ³n obligatoria de fuentes de verdad** antes de cada bloque
- âœ… **Proceso de validaciÃ³n por bloque** en 5 fases
- âœ… **ValidaciÃ³n de calidad arquitectural** obligatoria
- âœ… **Comandos de validaciÃ³n** especÃ­ficos
- âœ… **Checklist detallado** para cada fase del proceso

### **Mejoras en MetodologÃ­a**:
- âœ… **IntegraciÃ³n con Master Plan** para proyectos complejos
- âœ… **ValidaciÃ³n de patrones de diseÃ±o** especÃ­ficos
- âœ… **ValidaciÃ³n de naming conventions** detallada
- âœ… **ValidaciÃ³n de estructura de proyecto** arquitectural
- âœ… **Comandos automatizados** para validaciones

### **AlineaciÃ³n con Proyecto SGMM**:
- âœ… **Fuentes de verdad especÃ­ficas** del proyecto
- âœ… **Validaciones arquitecturales** para Clean Architecture
- âœ… **Comandos especÃ­ficos** para stack tecnolÃ³gico
- âœ… **IntegraciÃ³n con documentaciÃ³n** existente