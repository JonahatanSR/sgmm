# SISTEMA SGMM - REGLAS DE DESARROLLO
# Sistema de Gesti√≥n de Gastos M√©dicos Mayores
# Arquitectura: Clean Architecture con Hexagonal Design

## üéØ OBJETIVO PRINCIPAL
Implementar un sistema SGMM funcional, escalable y mantenible siguiendo arquitectura limpia y principios SOLID.

## üìã REGLAS DE DESARROLLO OBLIGATORIAS

### 1. METODOLOG√çA DE BLOQUES DE TRABAJO
- **BLOQUES AT√ìMICOS**: Unidades de trabajo completas de 30-90 minutos
- **REVISI√ìN OBLIGATORIA**: Consultar fuentes de verdad ANTES de iniciar cada bloque
- **VALIDACI√ìN POR BLOQUE**: Validaci√≥n r√°pida al finalizar cada bloque (5-10 min)
- **CERO DEUDA T√âCNICA**: Resolver problemas cr√≠ticos inmediatamente
- **DOCUMENTACI√ìN INLINE**: Comentarios en c√≥digo + actualizaci√≥n de README
- **COMMITS SIGNIFICATIVOS**: Un commit por bloque con mensaje descriptivo
- **CHECKPOINT**: Verificar que funciona antes de continuar al siguiente bloque

**Referencia**: Ver documentaci√≥n de fases en `/docs/FASE_*.md` para detalles completos

### 2. CRITERIOS DE VALIDACI√ìN POR TAREA OBLIGATORIOS
- **ANALIZAR IMPACTO COMPLETO**: ¬øQu√© se ve afectado por este cambio?
- **MAPEAR DEPENDENCIAS**: ¬øQu√© depende de esto y de qu√© depende esto?
- **VERIFICAR IMPORTS**: ¬øEst√°n correctos todos los imports necesarios?
- **COMPRENDER ECOSISTEMA**: ¬øC√≥mo se integra esto con el resto del sistema?
- **VALIDAR CON GATES**: Ejecutar validaciones antes de aceptar cambios
- **AN√ÅLISIS FORENSE**: Investigar causa ra√≠z antes de implementar soluciones

### 3. REVISI√ìN OBLIGATORIA DE FUENTES DE VERDAD (ANTES DE CADA BLOQUE)

#### **CHECKLIST OBLIGATORIO AL INICIO DE CADA BLOQUE**:
- [ ] **DATA_DICTIONARY.md**: Revisar campos, tipos, restricciones y reglas de negocio
- [ ] **DATABASE_SCHEMA_COMPLETE.md**: Validar estructura de tablas y relaciones
- [ ] **NAMING_CONVENTIONS.md**: Verificar convenciones de nomenclatura aplicables
- [ ] **USER_STORIES_GAP_ANALYSIS.md**: Confirmar funcionalidades requeridas
- [ ] **RF_RNF_VALIDATION.md**: Validar requerimientos funcionales y no funcionales
- [ ] **FASE_*.md**: Revisar plan espec√≠fico del bloque a implementar
- [ ] **MASTER_PLAN**: Si existe, revisar documentaci√≥n del plan maestro

#### **VALIDACI√ìN DE CONSISTENCIA**:
- [ ] **Campos de BD**: ¬øExisten todos los campos necesarios en el esquema?
- [ ] **Nomenclatura**: ¬øSigo las convenciones establecidas?
- [ ] **Arquitectura**: ¬øMantengo clean architecture y principios SOLID?
- [ ] **Dependencias**: ¬øIdentifico todas las dependencias del m√≥dulo?
- [ ] **Impacto**: ¬øEntiendo el impacto en otros m√≥dulos?

#### **DOCUMENTACI√ìN COMO FUENTE DE VERDAD**:
- **CONSULTAR SIEMPRE**: `/docs` antes de implementar cualquier funcionalidad
- **DICCIONARIO DE DATOS**: `/docs/DATA_DICTIONARY.md` - **CONSULTA OBLIGATORIA** antes de queries Prisma
- **CONVENCIONES DE NOMENCLATURA**: `/docs/NAMING_CONVENTIONS.md` - Gu√≠a detallada
- **PLANES DE FASES**: `/docs/FASE_*.md` - **CONSULTA OBLIGATORIA** para implementaci√≥n
- **DICCIONARIO = LEY**: Si hay conflicto entre c√≥digo y diccionario, el diccionario tiene raz√≥n
- **ACTUALIZAR AL CERRAR**: Documentar cuando se completa un m√≥dulo/funcionalidad
- **NO INVENTAR**: Usar la documentaci√≥n existente como base
- **VALIDAR CONSISTENCIA**: Asegurar que documentaci√≥n y c√≥digo est√©n alineados

### 4. VALIDACI√ìN DE CALIDAD ARQUITECTURAL (OBLIGATORIA)

#### **PRINCIPIOS ARQUITECTURALES OBLIGATORIOS**:
- **CLEAN ARCHITECTURE**: Seguir capas bien definidas (Domain, Application, Infrastructure)
- **SOLID PRINCIPLES**: Aplicar los 5 principios en todo el c√≥digo
- **HEXAGONAL DESIGN**: Desacoplar la l√≥gica de negocio de la infraestructura
- **DEPENDENCY INJECTION**: Usar inyecci√≥n de dependencias para desacoplamiento
- **INTERFACE SEGREGATION**: Crear interfaces espec√≠ficas y cohesivas
- **SINGLE RESPONSIBILITY**: Una clase = una responsabilidad
- **NO GOD CLASSES**: Evitar clases que hagan demasiado

#### **VALIDACI√ìN DE PATRONES DE DISE√ëO**:
- [ ] **Repository Pattern**: ¬øUso repositorios para acceso a datos?
- [ ] **Service Layer**: ¬øSeparo l√≥gica de negocio en servicios?
- [ ] **DTO Pattern**: ¬øUso DTOs para transferencia de datos?
- [ ] **Factory Pattern**: ¬øUso factories para creaci√≥n de objetos complejos?
- [ ] **Observer Pattern**: ¬øImplemento notificaciones correctamente?
- [ ] **Strategy Pattern**: ¬øUso estrategias para algoritmos variables?

#### **VALIDACI√ìN DE NAMING CONVENTIONS**:
- [ ] **Backend**: ¬øSigo kebab-case para archivos, PascalCase para clases?
- [ ] **Frontend**: ¬øSigo PascalCase para componentes, camelCase para funciones?
- [ ] **Base de Datos**: ¬øUso snake_case para tablas y campos?
- [ ] **Interfaces**: ¬øUso prefijo 'I' para interfaces?
- [ ] **Constantes**: ¬øUso UPPER_SNAKE_CASE para constantes?
- [ ] **Enums**: ¬øUso PascalCase para enums?

#### **VALIDACI√ìN DE ESTRUCTURA DE PROYECTO**:
- [ ] **Separaci√≥n de Capas**: ¬øMantengo Domain, Application, Infrastructure separados?
- [ ] **M√≥dulos**: ¬øOrganizo por m√≥dulos de negocio?
- [ ] **Dependencias**: ¬øLas dependencias apuntan hacia adentro (hacia Domain)?
- [ ] **Interfaces**: ¬øDefino interfaces en la capa de dominio?
- [ ] **Implementaciones**: ¬øImplemento en la capa de infraestructura?

### 2. DOCUMENTACI√ìN COMO FUENTE DE VERDAD
- **CONSULTAR SIEMPRE**: `/docs` antes de implementar cualquier funcionalidad
- **DICCIONARIO DE DATOS**: `/docs/DATA_DICTIONARY.md` - **CONSULTA OBLIGATORIA** antes de queries
- **ESQUEMA DE BD**: `/docs/DATABASE_SCHEMA_COMPLETE.md` - **CONSULTA OBLIGATORIA** para estructura
- **HISTORIAS DE USUARIO**: Validar funcionalidades contra requirements
- **DICCIONARIO = LEY**: Si hay conflicto entre c√≥digo y diccionario, el diccionario tiene raz√≥n
- **ACTUALIZAR DOCUMENTACI√ìN**: Mantener docs sincronizadas con c√≥digo

### 3. CONVENCIONES DE NOMENCLATURA

#### **Backend (Node.js + TypeScript)**
- **Archivos**: `kebab-case` (user-service.ts, employee-repository.ts)
- **Clases**: `PascalCase` (UserService, EmployeeRepository)
- **Interfaces**: `PascalCase` con prefijo `I` (IUserService, IEmployeeRepository)
- **Funciones**: `camelCase` (getUserById, createEmployee)
- **Constantes**: `UPPER_SNAKE_CASE` (MAX_FILE_SIZE, DEFAULT_TIMEOUT)
- **Variables**: `camelCase` (userEmail, employeeData)
- **Enums**: `PascalCase` (UserRole, EmployeeStatus)

#### **Frontend (React + TypeScript)**
- **Componentes**: `PascalCase` (UserProfile, EmployeeList)
- **Hooks**: `camelCase` con prefijo `use` (useAuth, useEmployeeData)
- **Archivos**: `kebab-case` (user-profile.tsx, employee-list.tsx)
- **Props**: `camelCase` (userId, employeeData)
- **Estados**: `camelCase` (isLoading, userData)

#### **Base de Datos**
- **Tablas**: `snake_case` en plural (employees, dependents)
- **Campos**: `snake_case` (employee_id, created_at)
- **√çndices**: `idx_tabla_campo` (idx_employees_email)
- **Foreign Keys**: `fk_tabla_campo` (fk_dependents_employee_id)

### 4. ESTRUCTURA DE PROYECTO

#### **Backend Structure**
```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/           # Configuraciones
‚îÇ   ‚îú‚îÄ‚îÄ modules/          # M√≥dulos de negocio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ employees/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/   # Entidades, interfaces, tipos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/ # Casos de uso, servicios
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/ # Repositorios, adapters
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dependents/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reports/
‚îÇ   ‚îú‚îÄ‚îÄ shared/           # Utilidades compartidas
‚îÇ   ‚îî‚îÄ‚îÄ server.ts         # Punto de entrada
‚îú‚îÄ‚îÄ prisma/               # Esquema y migraciones
‚îî‚îÄ‚îÄ docs/                 # Documentaci√≥n t√©cnica
```

#### **Frontend Structure**
```
frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/       # Componentes reutilizables
‚îÇ   ‚îú‚îÄ‚îÄ pages/           # P√°ginas de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ hooks/           # Custom hooks
‚îÇ   ‚îú‚îÄ‚îÄ services/        # Servicios de API
‚îÇ   ‚îú‚îÄ‚îÄ types/           # Tipos TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ utils/           # Utilidades
‚îÇ   ‚îî‚îÄ‚îÄ styles/          # Estilos globales
‚îî‚îÄ‚îÄ docs/                # Documentaci√≥n frontend
```

### 5. REGLAS DE C√ìDIGO

#### **TypeScript**
- **STRICT MODE**: Siempre habilitado
- **NO ANY**: Evitar tipo `any`, usar tipos espec√≠ficos
- **INTERFACES**: Preferir interfaces sobre types para objetos
- **ENUMS**: Usar enums para valores constantes
- **NULL SAFETY**: Manejar null/undefined expl√≠citamente
- **ASYNC/AWAIT**: Preferir sobre Promises.then()

#### **Error Handling**
- **TRY-CATCH**: En todas las operaciones as√≠ncronas
- **CUSTOM ERRORS**: Crear errores espec√≠ficos del dominio
- **LOGGING**: Registrar errores con contexto suficiente
- **USER-FRIENDLY**: Mostrar mensajes de error claros al usuario

#### **Testing**
- **UNIT TESTS**: Para l√≥gica de negocio
- **INTEGRATION TESTS**: Para APIs y servicios
- **MOCKING**: Mockear dependencias externas
- **COVERAGE**: Mantener cobertura > 80%

### 6. REGLAS DE BASE DE DATOS

#### **Prisma ORM**
- **SCHEMA FIRST**: Definir esquema antes de c√≥digo
- **MIGRATIONS**: Usar migraciones para cambios de BD
- **VALIDATIONS**: Validaciones en esquema Prisma
- **RELATIONS**: Definir relaciones expl√≠citas
- **INDEXES**: Crear √≠ndices para campos de b√∫squeda

#### **Queries**
- **PARAMETERIZED**: Usar par√°metros, nunca concatenaci√≥n
- **LIMITS**: Limitar resultados de consultas grandes
- **PAGINATION**: Para listas grandes
- **OPTIMIZATION**: Revisar performance de queries complejas

### 7. REGLAS DE SEGURIDAD

#### **Autenticaci√≥n**
- **SAML**: Usar SAML con Google Workspace
- **JWT**: Para sesiones despu√©s de SAML
- **COOKIES**: HttpOnly, Secure, SameSite
- **TIMEOUT**: Sesiones con expiraci√≥n autom√°tica

#### **Autorizaci√≥n**
- **ROLE-BASED**: Sistema de roles (EMPLOYEE, HR_ADMIN, SUPER_ADMIN)
- **RESOURCE-BASED**: Empleados solo ven sus propios datos
- **MIDDLEWARE**: Validar permisos en cada endpoint

#### **Datos Sensibles**
- **ENCRYPTION**: Datos sensibles encriptados
- **AUDIT TRAIL**: Registrar todas las acciones
- **PRIVACY**: Aceptaci√≥n de aviso de privacidad obligatoria
- **SOFT DELETE**: Nunca eliminaci√≥n f√≠sica

### 8. REGLAS DE ARCHIVOS Y DOCUMENTOS

#### **Google Drive Integration**
- **STRUCTURE**: Organizar por empleado/dependiente
- **NAMING**: Usar ID compuesto (3619-a01)
- **VALIDATION**: Validar tama√±o y tipo de archivo
- **SECURITY**: Control de acceso por roles

#### **File Upload**
- **MAX SIZE**: 5MB por archivo
- **ALLOWED TYPES**: PDF, JPG, JPEG, PNG
- **FIRST TIME**: Upload obligatorio para dependientes nuevos
- **METADATA**: Guardar informaci√≥n de upload

### 9. REGLAS DE REPORTES

#### **Generaci√≥n**
- **ON-DEMAND**: Generar din√°micamente, no almacenar
- **VIEWS**: Usar vistas SQL para reportes complejos
- **FORMATS**: Excel, PDF, CSV
- **FILTERING**: Por compa√±√≠a, fecha, estado

#### **Tipos de Reporte**
- **INSURER**: Para aseguradora con todos los dependientes
- **PAYROLL_DEDUCTIONS**: Para n√≥minas con dependientes extra
- **AUDIT**: Trail de auditor√≠a para RH

### 10. REGLAS DE PERFORMANCE

#### **Backend**
- **CACHING**: Cache para datos frecuentemente accedidos
- **PAGINATION**: Para listas grandes
- **LAZY LOADING**: Cargar datos bajo demanda
- **INDEXING**: √çndices en campos de b√∫squeda

#### **Frontend**
- **CODE SPLITTING**: Dividir c√≥digo por rutas
- **LAZY LOADING**: Cargar componentes bajo demanda
- **OPTIMIZATION**: Optimizar im√°genes y assets
- **BUNDLING**: Usar bundling eficiente

### 11. REGLAS DE DEPLOYMENT

#### **Docker**
- **MULTI-STAGE**: Builds optimizados
- **SECRETS**: Variables de entorno para secretos
- **HEALTH CHECKS**: Verificar salud de contenedores
- **LOGGING**: Configurar logging centralizado

#### **Environment**
- **SEPARATION**: Dev, Staging, Production
- **CONFIG**: Variables de entorno para configuraci√≥n
- **SECRETS**: Nunca hardcodear secretos
- **BACKUPS**: Backup autom√°tico de BD

### 12. REGLAS DE COMMITS Y VERSIONADO

#### **Git Commits**
- **CONVENTIONAL**: Usar Conventional Commits
- **ATOMIC**: Un commit = una funcionalidad
- **DESCRIPTIVE**: Mensajes claros y descriptivos
- **SIGNED**: Firmar commits cuando sea posible

#### **Versionado**
- **SEMANTIC**: Semantic Versioning (MAJOR.MINOR.PATCH)
- **CHANGELOG**: Mantener changelog actualizado
- **TAGS**: Tag releases importantes

### 13. REGLAS DE MONITOREO Y LOGGING

#### **Logging**
- **STRUCTURED**: JSON logs para parsing
- **LEVELS**: DEBUG, INFO, WARN, ERROR
- **CONTEXT**: Incluir contexto suficiente
- **CORRELATION**: IDs de correlaci√≥n para traces

#### **Monitoring**
- **METRICS**: M√©tricas de performance y uso
- **ALERTS**: Alertas para errores cr√≠ticos
- **DASHBOARDS**: Dashboards para monitoreo
- **HEALTH**: Health checks autom√°ticos

### 14. REGLAS DE DOCUMENTACI√ìN

#### **Code Documentation**
- **JSDoc**: Documentar funciones p√∫blicas
- **README**: README actualizado por m√≥dulo
- **API DOCS**: Documentaci√≥n de APIs
- **ARCHITECTURE**: Documentar decisiones arquitect√≥nicas

#### **User Documentation**
- **USER STORIES**: Historias de usuario claras
- **REQUIREMENTS**: RF y RNF documentados
- **MANUALS**: Manuales de usuario
- **FAQ**: Preguntas frecuentes

### 15. REGLAS DE CALIDAD

#### **Code Quality**
- **LINTING**: ESLint, Prettier configurados
- **FORMATTING**: Formato consistente
- **COMPLEXITY**: Evitar complejidad ciclom√°tica alta
- **DUPLICATION**: Evitar c√≥digo duplicado

#### **Reviews**
- **PULL REQUESTS**: Review obligatorio
- **CHECKLIST**: Checklist de review
- **TESTING**: Verificar que tests pasen
- **DOCUMENTATION**: Verificar documentaci√≥n actualizada

---

## üö® VALIDACIONES OBLIGATORIAS ANTES DE COMMIT

### **Backend**
- [ ] Tests unitarios pasan
- [ ] Tests de integraci√≥n pasan
- [ ] Linting sin errores
- [ ] Tipos TypeScript correctos
- [ ] Documentaci√≥n actualizada
- [ ] Schema Prisma validado
- [ ] Migraciones aplicadas

### **Frontend**
- [ ] Componentes renderizan correctamente
- [ ] Tests unitarios pasan
- [ ] Linting sin errores
- [ ] Tipos TypeScript correctos
- [ ] Responsive design verificado
- [ ] Accesibilidad b√°sica verificada

### **General**
- [ ] Funcionalidad probada manualmente
- [ ] Performance aceptable
- [ ] Seguridad verificada
- [ ] Documentaci√≥n actualizada
- [ ] Commits at√≥micos y descriptivos

---

## üìã PROCESO DE VALIDACI√ìN POR BLOQUE (OBLIGATORIO)

### **FASE 1: REVISI√ìN DE FUENTES DE VERDAD (ANTES DE INICIAR)**
- [ ] **DATA_DICTIONARY.md**: Campos, tipos, restricciones, reglas de negocio
- [ ] **DATABASE_SCHEMA_COMPLETE.md**: Estructura de tablas y relaciones
- [ ] **NAMING_CONVENTIONS.md**: Convenciones aplicables al bloque
- [ ] **USER_STORIES_GAP_ANALYSIS.md**: Funcionalidades requeridas
- [ ] **RF_RNF_VALIDATION.md**: Requerimientos funcionales y no funcionales
- [ ] **FASE_*.md**: Plan espec√≠fico del bloque
- [ ] **MASTER_PLAN**: Documentaci√≥n del plan maestro (si aplica)

### **FASE 2: AN√ÅLISIS DE IMPACTO (DURANTE EL BLOQUE)**
- [ ] **M√≥dulos afectados**: ¬øQu√© m√≥dulos se ven afectados?
- [ ] **Dependencias**: ¬øQu√© depende de esto y de qu√© depende esto?
- [ ] **APIs**: ¬øQu√© endpoints cambian?
- [ ] **Base de datos**: ¬øQu√© tablas/campos se modifican?
- [ ] **Frontend**: ¬øQu√© componentes se ven afectados?

### **FASE 3: VALIDACI√ìN ARQUITECTURAL (DURANTE EL BLOQUE)**
- [ ] **Principios SOLID**: ¬øAplico los 5 principios?
- [ ] **Clean Architecture**: ¬øMantengo separaci√≥n de capas?
- [ ] **Patrones de dise√±o**: ¬øUso patrones apropiados?
- [ ] **Naming conventions**: ¬øSigo convenciones establecidas?
- [ ] **Estructura de proyecto**: ¬øMantengo organizaci√≥n por m√≥dulos?

### **FASE 4: VALIDACI√ìN DE CALIDAD (AL FINALIZAR)**
- [ ] **Funcionalidad**: ¬øEl bloque cumple su objetivo?
- [ ] **Tests**: ¬øTests unitarios e integraci√≥n pasan?
- [ ] **Performance**: ¬øRendimiento aceptable?
- [ ] **Seguridad**: ¬øValidaciones y permisos correctos?
- [ ] **Documentaci√≥n**: ¬øDocumentaci√≥n actualizada?

### **FASE 5: CHECKPOINT (ANTES DE CONTINUAR)**
- [ ] **Funcionalidad probada**: ¬øProb√© manualmente?
- [ ] **Sin errores**: ¬øNo hay errores de compilaci√≥n?
- [ ] **Tests pasando**: ¬øTodos los tests pasan?
- [ ] **Commit realizado**: ¬øCommit at√≥mico y descriptivo?
- [ ] **Documentaci√≥n actualizada**: ¬øREADME y docs actualizados?

## üìã CHECKLIST DE AN√ÅLISIS ANTES DE CAMBIOS

### **Impacto**
- [ ] ¬øQu√© m√≥dulos se ven afectados?
- [ ] ¬øQu√© dependencias externas hay?
- [ ] ¬øQu√© APIs cambian?
- [ ] ¬øQu√© base de datos se modifica?

### **Arquitectura**
- [ ] ¬øSigue principios SOLID?
- [ ] ¬øMantiene clean architecture?
- [ ] ¬øNo viola separaci√≥n de capas?
- [ ] ¬øEs testable?

### **Seguridad**
- [ ] ¬øSe validan inputs?
- [ ] ¬øSe manejan errores correctamente?
- [ ] ¬øSe registra en audit trail?
- [ ] ¬øSe respetan permisos?

### **Performance**
- [ ] ¬øSe optimizan queries?
- [ ] ¬øSe usa caching cuando corresponde?
- [ ] ¬øSe evitan N+1 queries?
- [ ] ¬øSe limitan resultados?

---

## üîß COMANDOS DE VALIDACI√ìN OBLIGATORIOS

### **Validaci√≥n de Fuentes de Verdad**
```bash
# Verificar que documentaci√≥n existe y est√° actualizada
ls -la docs/DATA_DICTIONARY.md
ls -la docs/DATABASE_SCHEMA_COMPLETE.md
ls -la docs/NAMING_CONVENTIONS.md
ls -la docs/USER_STORIES_GAP_ANALYSIS.md
ls -la docs/RF_RNF_VALIDATION.md

# Verificar plan de fase espec√≠fico
ls -la docs/FASE_*.md
ls -la docs/masterPlan/
```

### **Validaci√≥n de C√≥digo Backend**
```bash
# Compilar TypeScript
cd backend && npx tsc --noEmit

# Ejecutar tests
npm test

# Linting
npm run lint

# Verificar Prisma
npx prisma generate
npx prisma validate
```

### **Validaci√≥n de C√≥digo Frontend**
```bash
# Compilar TypeScript
cd frontend && npx tsc --noEmit

# Ejecutar tests
npm test

# Linting
npm run lint

# Build de producci√≥n
npm run build
```

### **Validaci√≥n de Base de Datos**
```bash
# Verificar migraciones
npx prisma migrate status

# Validar esquema
npx prisma validate

# Generar cliente
npx prisma generate
```

### **Validaci√≥n de Arquitectura**
```bash
# Verificar estructura de carpetas
find src -type d -name "domain" -o -name "application" -o -name "infrastructure"

# Verificar imports (dependencias hacia adentro)
grep -r "import.*domain" src/infrastructure/
grep -r "import.*infrastructure" src/domain/

# Verificar convenciones de nomenclatura
find src -name "*.ts" | xargs grep -l "class.*[A-Z]"
find src -name "*.ts" | xargs grep -l "interface.*[A-Z]"
```

## üéØ OBJETIVOS DE CALIDAD

- **Cobertura de tests**: > 80%
- **Performance**: < 2s respuesta API
- **Disponibilidad**: 99.9%
- **Seguridad**: 0 vulnerabilidades cr√≠ticas
- **Mantenibilidad**: Complejidad ciclom√°tica < 10
- **Documentaci√≥n**: 100% de APIs documentadas

---

*√öltima actualizaci√≥n: 2025-01-15*
*Versi√≥n: 2.0*
*Responsable: Equipo de Desarrollo SGMM*

## üìã CAMBIOS EN VERSI√ìN 2.0

### **Nuevas Funcionalidades**:
- ‚úÖ **Revisi√≥n obligatoria de fuentes de verdad** antes de cada bloque
- ‚úÖ **Proceso de validaci√≥n por bloque** en 5 fases
- ‚úÖ **Validaci√≥n de calidad arquitectural** obligatoria
- ‚úÖ **Comandos de validaci√≥n** espec√≠ficos
- ‚úÖ **Checklist detallado** para cada fase del proceso

### **Mejoras en Metodolog√≠a**:
- ‚úÖ **Integraci√≥n con Master Plan** para proyectos complejos
- ‚úÖ **Validaci√≥n de patrones de dise√±o** espec√≠ficos
- ‚úÖ **Validaci√≥n de naming conventions** detallada
- ‚úÖ **Validaci√≥n de estructura de proyecto** arquitectural
- ‚úÖ **Comandos automatizados** para validaciones

### **Alineaci√≥n con Proyecto SGMM**:
- ‚úÖ **Fuentes de verdad espec√≠ficas** del proyecto
- ‚úÖ **Validaciones arquitecturales** para Clean Architecture
- ‚úÖ **Comandos espec√≠ficos** para stack tecnol√≥gico
- ‚úÖ **Integraci√≥n con documentaci√≥n** existente